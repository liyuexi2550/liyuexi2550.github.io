<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>my first post</title>
    <url>/2023/03/03/my-first-post/</url>
    <content><![CDATA[<p>This is my first post.I write the post to remember this exciting moment….</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>【python】爬取堆糖的一些图片</title>
    <url>/2023/03/14/%E3%80%90python%E3%80%91%E7%88%AC%E5%8F%96%E5%A0%86%E7%B3%96%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>本博文爬取的都是公开分享的官方允许爬取的图片，不涉及隐私，爬取的数据量很小，仅用于技术学习。</p>
<h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><p>IDE：pycharm<br>浏览器：Chrome或者Firefox，别的也行，只要有审查元素的功能就行<br>工具包: requests模块，如果未安装，则执行pip install requests<br>要爬取的图片所在的网址：<br><a href="https://www.duitang.com/search/?kw=%E5%B0%8F%E5%A7%90%E5%A7%90&amp;type=feed">https://www.duitang.com/search/?kw=%E5%B0%8F%E5%A7%90%E5%A7%90&amp;type=feed</a></p>
<h2 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h2><p>以Chrome为例，首先进入<br><a href="https://www.duitang.com/search/?kw=%E5%B0%8F%E5%A7%90%E5%A7%90&amp;type=feed">https://www.duitang.com/search/?kw=%E5%B0%8F%E5%A7%90%E5%A7%90&amp;type=feed</a><br>然后按F12或鼠标右键菜单中的检查选项<br>按如下所示点击，可以看到json文件的内容，每个json文件包含了24张图片的信息，包括图片的url地址<br><img src="../img/%E6%8C%87%E5%BC%95.PNG" alt="指引"><br>以第二个json文件为例，我们按照json对象的层级关系找到了第2张图片的地址，如下所示<br><img src="../img/%E6%89%BE%E5%88%B0%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80.PNG" alt="图片地址"><br>下面是要请求的json文件的URL<br><img src="../img/json_url.PNG" alt="json_url"><br>注意下面三个URL的区别<br><img src="../img/%E7%AC%AC%E4%B8%80%E4%B8%AAjson%E6%96%87%E4%BB%B6.PNG" alt="第一个json"><br><img src="../img/%E7%AC%AC%E4%BA%8C%E4%B8%AAjson%E6%96%87%E4%BB%B6.PNG" alt="第二个json"><br><img src="../img/%E7%AC%AC%E4%B8%89%E4%B8%AAjson%E6%96%87%E4%BB%B6.PNG" alt="第三个json"></p>
<ol>
<li>根据上述数据，写代码，如下所示。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -- coding: utf-8 --</span></span><br><span class="line"><span class="comment"># @Time : 2023/3/14 15:32</span></span><br><span class="line"><span class="comment"># @Author : LiYuexi</span></span><br><span class="line"><span class="comment"># @File : 堆糖.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网页前缀（不包括数据）</span></span><br><span class="line">pre_url = <span class="string">&#x27;https://www.duitang.com/napi/blogv2/list/by_search/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTP请求携带的数据</span></span><br><span class="line"><span class="comment"># 请按照你当时的实际抓到的json的url，填写data中的数据，每个人都不一样</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;kw&#x27;</span>: <span class="string">&#x27;小姐姐&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;after_id&#x27;</span>: <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;feed&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;include_fields&#x27;</span>: <span class="string">&#x27;top_comments,is_root,source_link,item,buyable,root_id,status,like_count,like_id,sender,album,reply_count,favorite_blog_id&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;_type&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;_&#x27;</span>: <span class="string">&#x27;1678775422730&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求头信息</span></span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="comment">#爬取3次，每次爬24张图片</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="comment"># 发送HTTP请求，请求一个包含了24张图片url信息的json文件，请求方式是get，并依次指定不带数据的url，携带的数据和请求头</span></span><br><span class="line">    response = requests.get(url=pre_url,params=data,headers=header)</span><br><span class="line">    <span class="comment"># &#x27;_&#x27;表示组号，将&#x27;_&#x27;加1，表示请求下一组</span></span><br><span class="line">    data[<span class="string">&#x27;_&#x27;</span>] = <span class="built_in">str</span>(<span class="built_in">int</span>(data[<span class="string">&#x27;_&#x27;</span>]) + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 起始图片id加24，也表示请求下一组</span></span><br><span class="line">    data[<span class="string">&#x27;after_id&#x27;</span>] = <span class="built_in">str</span>(<span class="built_in">int</span>(data[<span class="string">&#x27;after_id&#x27;</span>]) + <span class="number">24</span>)</span><br><span class="line">    <span class="comment">#将HTTP响应的数据字段从字符串格式转化为json格式</span></span><br><span class="line">    response_json = response.json()</span><br><span class="line">    <span class="comment"># 检索json格式中的object_list字段</span></span><br><span class="line">    object_list = response_json[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;object_list&#x27;</span>]</span><br><span class="line">    <span class="comment"># 依次下载列表中每一个url所指定的图片</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> object_list:</span><br><span class="line">        img_url = i[<span class="string">&#x27;photo&#x27;</span>][<span class="string">&#x27;path&#x27;</span>]</span><br><span class="line">        <span class="comment"># 发送HTTP请求，请求方式是get，请求一张图片</span></span><br><span class="line">        img = requests.get(url=img_url,headers=header)</span><br><span class="line">        <span class="comment"># 将图片保存到本地路径，事先创建好图片文件夹</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;图片\\&#x27;</span> + <span class="built_in">str</span>(num) + <span class="string">&#x27;.jpeg&#x27;</span>, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="comment">#将图片的内存写入文件</span></span><br><span class="line">            f.write(img.content)</span><br><span class="line">        <span class="comment"># 计数变量加1</span></span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java高级特性】注解</title>
    <url>/2023/03/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%91%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<ul>
<li>java在JDK1.5以后引入了注解(Annotation)的功能。</li>
<li>注解主要用于说明代码的，是代码的特殊标记，因此是编译器和JVM可见的，而通常的注释是被编译器和JVM完全忽略的，这就是注解和注释的最主要区别。</li>
<li>注解主要有三个方面的作用：分别是编写文档、编译检查、代码分析</li>
<li>JavaSE中，注解作用有限，但在JavaEE中，作用很大，可以代替XML配置</li>
</ul>
<h2 id="一、常用注解"><a href="#一、常用注解" class="headerlink" title="一、常用注解"></a>一、常用注解</h2><h3 id="1-用于文档生成的注解"><a href="#1-用于文档生成的注解" class="headerlink" title="1. 用于文档生成的注解"></a>1. 用于文档生成的注解</h3><div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>格式要求</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>@author</td>
<td>标明开发该类的作者</td>
<td>@author 姓名/组织/邮箱</td>
<td>多个作者之间用逗号隔开</td>
</tr>
<tr>
<td>@version</td>
<td>标明该类的版本</td>
<td>@version 当前版本号</td>
<td>————————</td>
</tr>
<tr>
<td>@see</td>
<td>标明相关联的类</td>
<td>@see 类名/方法名</td>
<td>可用于类和方法</td>
</tr>
<tr>
<td>@since</td>
<td>从哪个版本开始增加</td>
<td>@since 创建日期/初始版本号</td>
<td>————————</td>
</tr>
<tr>
<td>@param</td>
<td>对方法参数的说明</td>
<td>@param 形参名 形参类型 形参说明</td>
<td>1. 仅用于方法；2. 没有参数则不能写；3. 可并列多个</td>
</tr>
<tr>
<td>@return</td>
<td>对方法返回值的说明</td>
<td>@return 返回值类型 返回值说明</td>
<td>1. 仅用于方法；2.返回值是void则不能写</td>
</tr>
<tr>
<td>@exception</td>
<td>对方法可能抛出的异常进行说明</td>
<td>@exception 异常类型 异常说明</td>
<td>1. 仅用于方法；2.方法没有throws抛出则不能写；3. 可并列多个</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-用于编译时格式检查的注解"><a href="#2-用于编译时格式检查的注解" class="headerlink" title="2. 用于编译时格式检查的注解"></a>2. 用于编译时格式检查的注解</h3><div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>格式要求</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Override</td>
<td>限定重写父类方法</td>
<td>@Override</td>
<td>多个作者之间用逗号隔开</td>
</tr>
<tr>
<td>@Deprecated</td>
<td>表示所修饰元素已过时，通常因为所修饰的结构或存在更好的选择</td>
<td>@Deprecated</td>
<td>————————</td>
</tr>
<tr>
<td>@SuppressWarnings</td>
<td>抑制编译器警告</td>
<td>@SuppressWarnings<br/>(“警告类型”)</td>
<td>警告类型有deprecation、unchecked、fallthrough、path等</td>
</tr>
</tbody>
</table>
</div>
<h3 id="下面这段代码展示了以上注解的用法"><a href="#下面这段代码展示了以上注解的用法" class="headerlink" title="下面这段代码展示了以上注解的用法"></a>下面这段代码展示了以上注解的用法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiYuexi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Dog</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 7 March 2023</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="comment">//名字</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> name;</span><br><span class="line">    <span class="comment">//种类</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> species;</span><br><span class="line">    <span class="comment">//健康值</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> health;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> food</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal eats &quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal walks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHealth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> health;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">suicide</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal suicides&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog eats &quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog walks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog plays something&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">attack</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">health</span> <span class="operator">=</span> getHealth();</span><br><span class="line">        <span class="keyword">if</span>(health &lt; <span class="number">0</span>||health &gt; <span class="number">100</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">        <span class="keyword">if</span>(getHealth() &gt;= <span class="number">60</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-用于替代配置文件的注解"><a href="#3-用于替代配置文件的注解" class="headerlink" title="3. 用于替代配置文件的注解"></a>3. 用于替代配置文件的注解</h3><p>Servlet3.0提供了注解，使得不需要在web.xml文件中进行Servlet的配置<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.servlet.LoginServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><br>使用@WebServlet注解替代上述冗长的XML配置信息，如下所示。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;LoginServlet&quot;, value = &quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二、自定义注解"><a href="#二、自定义注解" class="headerlink" title="二、自定义注解"></a>二、自定义注解</h2><ul>
<li>使用@interface声明自定义Annotation，本质上就是一个类</li>
<li>自定义注解自动继承java.lang.annotation.Annotation接口</li>
<li>自定义Annotation可以有成员变量，其类型可为八种基本数据类型、String类型、Class类型、enum类型、Annotation类型以及上述类型的数组形式</li>
<li>成员变量声明为无参数方法的形式，如String value();</li>
<li>没有成员变量的Annotation称为标记，包含成员变量的Annotation称为元数据Annotation</li>
<li>成员变量如果只有一个，一般命名为value，也可以用别的名字</li>
<li>成员变量如果有多个，可以用以value命名的数组，如String[] value();，也可用别的名字</li>
<li>使用 default 默认值 来为成员变量指定默认值，如String value() default “hello”;</li>
<li>如果没有给成员变量指定默认值，当在使用Annotation时，必须指定参数值，如@MyAnnotation(value = “hello”)</li>
<li>可以没有成员变量</li>
</ul>
<p>下面是一个例子<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、元注解-meta-annotation"><a href="#三、元注解-meta-annotation" class="headerlink" title="三、元注解(meta-annotation)"></a>三、元注解(meta-annotation)</h2><ul>
<li>元Annotation用于修饰其他Annotation</li>
<li>JDK5.0提供了4个标准元注解，分别是@Retention、@Target、@Documented、@Inherited</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>格式要求</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Retention</td>
<td>指定被修饰Annotation的生命周期</td>
<td>@Retention(状态值)</td>
<td>状态值有三种，见后文</td>
</tr>
<tr>
<td>@Target</td>
<td>指定被修饰的Annotation能用于修饰哪些程序元素</td>
<td>@Target({若干程序元素})</td>
<td>可指定元素见后文</td>
</tr>
<tr>
<td>@Documented</td>
<td>指定被修饰的Annotation将被javadoc工具提取成文档</td>
<td>@Documented</td>
<td>定义为@Documented的注解必须设置Retention的值为RUNTIME</td>
</tr>
<tr>
<td>@Inherited</td>
<td>指定被修饰的Annotation具有继承性</td>
<td>@Inherited</td>
<td>所修饰的Annotation修饰的类的子类自动具有该注解</td>
</tr>
</tbody>
</table>
</div>
<p>@Retention的成员变量可被指定为三种值:</p>
<ol>
<li>RetentionPolicy.SOURCE 意味所修饰的注解只在编译阶段起作用，不会保留在class文件中</li>
<li>RetentionPolicy.CLASS 默认行为，所修饰注解会被保留在class文件中，但不会保留在运行阶段</li>
<li>RetentionPolicy.RUNTIME 保留在class文件中，同时还保留在运行阶段，加载在内存当中，能通过反射获取</li>
</ol>
<p>@Target的成员变量是一个数组，可被指定为一个或多个以下值：</p>
<ol>
<li>ElementType.TYPE </li>
<li>ElementType.FIELD</li>
<li>ElementType.METHOD</li>
<li>ElementType.PARAMETER</li>
<li>ElementType.CONSTRUCTOR</li>
<li>ElementType.LOCAL_VARIABLE</li>
</ol>
<p>关于@Documented，下面是一个例子<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.FIELD,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于@Inherited的存在，kid类自动继承其父类Test的注解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">kid</span> <span class="keyword">extends</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="以下是JDK-8的新特性"><a href="#以下是JDK-8的新特性" class="headerlink" title="以下是JDK 8的新特性"></a>以下是JDK 8的新特性</h3><h2 id="四、可重复注解"><a href="#四、可重复注解" class="headerlink" title="四、可重复注解"></a>四、可重复注解</h2><p>在JDK 8以前，只能如此实现重复注解：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line">    MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnnotations(&#123;@MyAnnotation(&quot;hello&quot;),@MyAnnotation(&quot;world&quot;)&#125;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>jdk 8以来，可以这么实现<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotations&#123;</span><br><span class="line">    MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnnotation(&quot;hello&quot;)</span></span><br><span class="line"><span class="meta">@MyAnnotation(&quot;world&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注：<br>1.在MyAnnotation上声明Repeatable，成员变量值为MyAnnotations.class<br>2.保证MyAnnotation的元注解@Retention和@Target和MyAnnotations的@Retention和@Target一模一样</p>
<h2 id="五、类型注解"><a href="#五、类型注解" class="headerlink" title="五、类型注解"></a>五、类型注解</h2><ul>
<li>JDK 8之后，@Target的参数类型ElementType枚举值多了两个：TYPE_PARAMETER和TYPE_USE</li>
<li>JDK 8以前，注解只能写在声明的地方；JDK 8以后，注解可以写在任何地方，只要@Target值中包含TYPE_PARAMETER或TYPE_USE。</li>
</ul>
<ol>
<li>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中</li>
<li>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中</li>
</ol>
<p>下面是ElementType.TYPE_PARAMETER的用法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;<span class="meta">@MyAnnotation()</span> T&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE_PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是ElementType.TYPE_USE的用法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;<span class="meta">@MyAnnotation()</span> T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> <span class="keyword">throws</span> <span class="meta">@MyAnnotation</span> RuntimeException&#123;</span><br><span class="line">        ArrayList&lt;<span class="meta">@MyAnnotation</span> String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="meta">@MyAnnotation</span> <span class="type">int</span>) <span class="number">10L</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java高级特性</tag>
      </tags>
  </entry>
  <entry>
    <title>【尚硅谷】Java核心基础之day00_计算机基础知识--学习笔记</title>
    <url>/2023/03/06/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%91Java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E4%B9%8Bday00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="day00-编程入门（内容来源于尚硅谷）"><a href="#day00-编程入门（内容来源于尚硅谷）" class="headerlink" title="day00_编程入门（内容来源于尚硅谷）"></a>day00_编程入门（内容来源于尚硅谷）</h1><h2 id="0-1-概述"><a href="#0-1-概述" class="headerlink" title="0.1 概述"></a>0.1 概述</h2><p>计算机包括<strong>硬件(hardware)</strong> 和<strong>软件(software)</strong> 两部分。硬件包括计算机中看得见的物理部分，而软件提供看不见的指令。这些指令控制硬件并且使得硬件完成特定的任务。</p>
<ul>
<li><p><strong>程序设计</strong></p>
<ul>
<li><strong>定义</strong>：创建（或开发）软件。软件包含了指令，告诉计算机做什么。</li>
<li><strong>应用场景</strong>：软件遍布我们周围。除了个人计算机，飞机、汽车、手机甚至烤面包机中，同样运行着软件。</li>
</ul>
</li>
<li><p><strong>程序设计语言</strong><br>软件开发人员在称为程序设计语言的强大工具的帮助下创建软件。</p>
</li>
</ul>
<ul>
<li><h4>如何选择该学习哪种程序设计语言？</h4>

<ul>
<li>程序设计语言有很多种，每种语言都是为了实现某个特定的目的而发明的。</li>
<li>你会困惑哪种语言是最好的。事实上，<strong>没有“最好”的语言</strong>。每种语言都有它的长处和短处。</li>
<li>经验丰富的程序员知道各种语言擅长的应用场景。因此，会尽可能的掌握各种不同的程序设计语言。</li>
<li>如果你掌握了一种编程语言，应该会更容易上手其它的编程语言。关键是学习<strong>如何使用程序设计方法来解决问题。这也是本套课程的主旨。</strong></li>
</ul>
</li>
</ul>
<h2 id="0-2-计算机硬件介绍"><a href="#0-2-计算机硬件介绍" class="headerlink" title="0.2 计算机硬件介绍"></a>0.2 计算机硬件介绍</h2><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.jpg#pic_center" alt="计算机硬件组成"></p>
<center><b>图0-1 计算机硬件组成</b></center>

<p>在个人计算机上，总线搭建在主板上，主板是一个连接计算机各个部分的电路板。</p>
<p><img src="../img/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png#pic_center" alt="冯诺依曼体系结构"></p>
<center><b>图0-2 冯 • 诺依曼体系结构(源于尚硅谷)</b></center>

<p><strong>冯 • 诺依曼体系结构</strong>是现代计算机的基础,现在大多数计算机仍是冯诺伊曼计算机的组织结构，只是作了一点改进而已，并没有从根本上突破冯体系结构的束缚。冯 • 诺依曼也因此被人们称为“计算机之父”。</p>
<h3 id="0-2-1-中央处理器"><a href="#0-2-1-中央处理器" class="headerlink" title="0.2.1 中央处理器"></a>0.2.1 中央处理器</h3><ul>
<li><strong>中央处理器(Central Processing Unit,CPU)</strong> 是计算机的大脑。它从内存中获取指令，然后执行这些指令。<br>包括：<strong>控制单元(control unit)</strong> 和<strong>算术/逻辑单元(arithmetic/logic unit)</strong>。<ul>
<li>控制单元：用于控制和协调其他组件的动作。</li>
<li>算数/逻辑单元：用于完成数值运算(+、-、*、/)和逻辑运算(比较)。</li>
</ul>
</li>
</ul>
<p><img src="../img/CPU.jpg#pic_center" alt="CPU"></p>
<center><b>图0-3 CPU</b></center>

<ul>
<li><p>每台计算机都有一个内部时钟，该时钟以固定速度发射电子脉冲。时钟速度越快，在给定的时间段内执行的指令就越多。速度的计量单位是<strong>赫兹(Hz)</strong>。1Hz相当于每秒1个脉冲。随着CPU速度不断提高，目前以吉兆赫(GHz)来表述。</p>
</li>
<li><p>最初一个CPU只有一个<strong>核(core)</strong>，核是处理中实现指令读取和执行的部分。一个多核CPU是一个具有两个或者更多独立核的组件，可提高CPU的处理能力。</p>
</li>
<li><p>现在的CPU都是构建在一块小小的硅半导体芯片上，这块芯片上包含数百万称为晶体管的小电路开关上，用于处理信息。</p>
</li>
<li><p>1KHz = 1024Hz<br>1MHz = 1024KHz<br>1GHz = 1024MHz</p>
</li>
</ul>
<h4> IT定律之计算机行业发展规律</h4>

<ul>
<li><strong>摩尔定律(Moore’s Law)</strong></li>
<li><strong>安迪-比尔定律(Andy and Bill’s Law)</strong></li>
<li><strong>反摩尔定律(Reverse Moore’s Law)</strong></li>
</ul>
<ol>
<li>摩尔定律(Moore’s Law)是由英特尔(Intel)创始人之一戈登·摩尔(Gordon Moore)提出来的。其内容为：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。</li>
<li>安迪-比尔定律(Andy and Bill’s Law)描述了硬件产商和软件产商之间的关系。即比尔要拿走安迪所给的(What Andy gives,Bill takes away)。个人电脑工业整个的生态链是这样，以微软为首的软件开发商吃掉硬件提升带来的全部好处，迫使用户更新让惠普和戴尔等公司受益，而这些整机生产厂商再向英特尔这样的半导体厂订货购买新的芯片，同时向Seagate等外设厂购买新的外设。在这中间，各家的利润先后得到相应的提升，股票也随着增长。各个硬件半导体和外设公司再将利润投入研发，按照摩尔定理制定的速度，提升硬件性能，为微软下一步更新软件、吃掉硬件性能做准备。当然，微软和其它软件开发商在吃掉大部分硬件提升好处的同时，或多或少地给用户带来一些新东西。</li>
<li>反摩尔定律(Reverse Moore’s Law)是Google的前CEO埃里克·施密特提出的，如果你反过来看摩尔定律，一个IT公司如果今天和18个月前卖掉同样多的、同样的产品，它的营业额就要降一半。IT界把它称为反摩尔定律。反摩尔定律对于所有的IT公司来讲，都是非常可怕的，因为一个IT公司花了同样的劳动，却只得到以前一半的收入，反摩尔定律逼着所有的硬件设备公司必须赶上摩尔定律所规定的更新速度，而所有的硬件和设备生产厂活得都是非常辛苦的。</li>
</ol>
<h3 id="0-2-2-持久化存储设备"><a href="#0-2-2-持久化存储设备" class="headerlink" title="0.2.2 持久化存储设备"></a>0.2.2 持久化存储设备</h3><p>内存中的信息在断电时会丢失。那我们可以考虑将程序和数据永久的保存在存储设备上。当计算机确实需要这些数据时，再移入内存时，因为从内存中读取比从存储设备读取要快得多。<br>存储设备主要有以下三种：</p>
<ul>
<li><strong>磁盘驱动器</strong><br>每台计算机至少有一个硬盘驱动器。硬盘(hard disk)用于永久的保存数据和程序。</li>
</ul>
<p><img src="../img/7527a5076ed34269939b516b7bf090ae.png#pic_center" alt="逻辑硬盘"></p>
<center><b>图0-4 逻辑硬盘</b></center>

<p><br/><img src="../img/%E7%A3%81%E7%9B%98.jpeg#pic_center" alt="硬盘"></p>
<center><b>图0-5 物理硬盘</b></center>

<ul>
<li><strong>光盘驱动器(CD和DVD)</strong><br>CD的容量可达700MB<br>DVD的容量可达4.7GB<br><img src="../img/%E5%85%89%E9%A9%B1.jpg#pic_center" alt="光驱"><center><b>图0-6 光驱</b></center>

</li>
</ul>
<p><br /></p>
<ul>
<li><strong>USB闪存驱动器</strong><br><strong>USB：Universal Serial Bus 通用串行总线</strong><br>可以使用USB将打印机、数码相机、鼠标、外部硬盘驱动器连接到计算机上。USB闪存驱动器很小，是可用于存储和传输数据的设备。<br><br/><br><img src="../img/U%E7%9B%98.jpg#pic_center" alt="U盘"><br><center><b>图0-7 U盘</b></center><br><br /></li>
</ul>
<h3 id="0-2-3-内存"><a href="#0-2-3-内存" class="headerlink" title="0.2.3 内存"></a>0.2.3 内存</h3><h4>比特(bit)和字节(byte)</h4>

<ul>
<li><p>在讨论内存前，先清楚数据是如何存储在计算机中的。</p>
</li>
<li><p>计算机就是一系列的电路开关。每个开关存在两种状态：关(off)和开(on)。如果电路是开的，它的值是1。如果电路是关的，它的值是0。</p>
</li>
<li><p><strong>一个0或者1存储为一个比特(bit)，是计算机中最小的存储单位</strong>。</p>
</li>
<li><p><strong>计算机中最基本的存储单元是字节(byte)</strong>。<strong>每个字节由8个比特构成</strong>。</p>
</li>
<li><p>计算机的存储能力是以字节和多字节来衡量的。如下：<br><strong>千字节(kilobyte,KB) = 1024B<br>兆字节(megabyte,MB) = 1024KB<br>千兆字节(gigabyte,GB) = 1024MB<br>万亿字节(terabyte,TB) = 1024GB</strong></p>
</li>
<li><p>PB指petabyte，它是较高级的存储单位，其上还有EB、ZB、YB等单位。</p>
<h4> 什么是内存？</h4>
</li>
<li><p>内存(也叫Random-Access Memory,RAM)：由一个有序的字节序列组成，用于存储程序及程序需要的数据。</p>
</li>
<li><strong>一个程序和它的数据在被CPU执行前必须移到计算机的内存中。</strong></li>
<li><strong>每个字节都有一个唯一的地址。</strong> 见下图。使用这个地址确定字节的位置，以便于存储和获取数据。<br><br/></li>
</ul>
<p><img src="../img/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.jpg#pic_center" alt="内存空间"></p>
<center><b>图0-8 内存空间</b></center>

<ul>
<li>一个计算机具有的RAM越多，它的运行速度越快，但是此规律是有限制的。</li>
<li>内存与CPU一样，也构建在表面嵌有数百万晶体管的硅半导体芯片上。但内存芯片更简单、更低速、更便宜。</li>
<li>计算机CPU和内存的交互是最频繁的，内存是我们的告诉缓存区，用户磁盘和CPU的交互，而CPU运转速度越来越快，磁盘远远跟不上CPU的读写速度。</li>
</ul>
<p><img src="../img/%E5%86%85%E5%AD%98%E6%9D%A1.jpeg#pic_center" alt="内存条"></p>
<center><b>图0-9 内存条</b></center>

<p><img src="../img/CPU%E5%86%85%E5%AD%98%E7%A1%AC%E7%9B%98.jpg#pic_center" alt="CPU、内存和硬盘之间的交互关系"></p>
<center><b>图0-10 CPU、内存和硬盘之间的交互关系</b></center>

<ul>
<li>实测发现：<strong>内存存取数据的速度比硬盘的存取速度快10倍</strong>，在某些环境里，硬盘和内存之间的速度差距可能会更大。而<strong>CPU的速度比内存不知还要快多少倍</strong>。当我们把程序从硬盘放到内存以后，CPU就直接在内存运行程序，这样比CPU直接在硬盘运行程序就要快很多。</li>
<li>内存解决了一部分CPU运行过快，而硬盘数据存取太慢的问题，提高了我们的电脑的运行速度。内存就如同一条“高速车道”一般，数据由传输速度较慢的硬盘通过这条高速车道传送至CPU进行处理！</li>
<li><strong>但内存是带电存储的(一旦断电数据就会消失)，而且容量有限，所以要长时间储存程序或数据就需要使用硬盘</strong>。</li>
<li>内存在这里起了两个作用：</li>
</ul>
<ol>
<li>保存从硬盘读取的数据，提供给CPU使用</li>
<li>保存CPU的一些临时执行结果，以使CPU下次使用或保存到硬盘</li>
</ol>
<ul>
<li>大家都知道有内存和硬盘之说，其实内存就是一种RAM(Random Access Memory)技术，而ROM(Read Only Memory)则类似于硬盘技术，两者都是存储器，只是RAM的速度要远远高于ROM的速度。</li>
</ul>
<h3 id="0-2-4-输入和输出设备"><a href="#0-2-4-输入和输出设备" class="headerlink" title="0.2.4 输入和输出设备"></a>0.2.4 输入和输出设备</h3><ul>
<li>常见的输入设备：键盘(Keyboard)和鼠标(mouse)</li>
<li>常见的输出设备：显示器(monitor)和打印机(printer)</li>
<li>显示器屏幕分辨率：是指显示设备水平和垂直方向上显示的像素(px)数<ul>
<li>分辨率可以手工设置。</li>
<li><strong>分辨率越高，图像越锐化、越清晰</strong>。<center><b>表0-1 知名手机品牌屏幕参数表</b></center>

</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>品牌</th>
<th>尺寸</th>
<th>像素</th>
<th>像素密度</th>
</tr>
</thead>
<tbody>
<tr>
<td>华为mate 20 x</td>
<td>7.2</td>
<td>2244x1080像素</td>
<td>345ppi</td>
</tr>
<tr>
<td>华为mate 20</td>
<td>6.53</td>
<td>2244x1080像素</td>
<td>381ppi</td>
</tr>
<tr>
<td>华为mate 20 pro</td>
<td>6.39</td>
<td>3120x1440像素</td>
<td>538ppi</td>
</tr>
<tr>
<td>小米8 SE</td>
<td>5.88</td>
<td>2244x1080像素</td>
<td>423ppi</td>
</tr>
<tr>
<td>小米8</td>
<td>6.21</td>
<td>2244x1080像素</td>
<td>401ppi</td>
</tr>
<tr>
<td>苹果 iphone8</td>
<td>4.7</td>
<td>1334x750像素</td>
<td>326ppi</td>
</tr>
<tr>
<td>苹果 iphone8 plus</td>
<td>5.5</td>
<td>1920x1080像素</td>
<td>401ppi</td>
</tr>
</tbody>
</table>
</div>
<p><img src="../img/%E5%85%AC%E5%BC%8F.PNG" alt="公式"></p>
<h3 id="0-2-5-通信设备"><a href="#0-2-5-通信设备" class="headerlink" title="0.2.5 通信设备"></a>0.2.5 通信设备</h3><ul>
<li>计算机可以通过通信设备进行联网。</li>
<li>常见的设备有：<ul>
<li>拨号调制解调器：使用的是电话线，传输速度可达56000bps(bps:每秒比特)</li>
<li>DSL(数字用户线)：使用的也是电话线，但传输速度较上面的快20倍</li>
<li>电缆调制解调器：利用有线电视电缆进行数据传输，通常速度比DSL快</li>
<li>网络接口卡(NIC)：将计算机接入局域网(LAN)的设备。局域网通常用于大学、商业组织和政府组织，速度甚至可达1000Mbps</li>
<li>无线网络：在家庭、商业和学校中极其常见，计算机可通过无线适配器连接到局域网或Internet上</li>
</ul>
</li>
</ul>
<h2 id="0-3-计算机发展史上的鼻祖"><a href="#0-3-计算机发展史上的鼻祖" class="headerlink" title="0.3  计算机发展史上的鼻祖"></a>0.3  计算机发展史上的鼻祖</h2><h4>图灵</h4>
最近半个世纪以来，世界计算机科学界的重大进步，离不开图灵等人的理论奠基作用和多方面的的开创性研究成果。图灵是当之无愧的计算机科学和人工智能之父。甚至认为，他在技术上的贡献及对未来世界的影响几乎可与牛顿、爱因斯坦等巨人比肩。
图灵论文中的“用有限的指令和有限的存储空间可算尽一切可算之物”理论让当时所有的科学家震惊。
美国计算机学会(ACM)的年度“图灵奖”，自从1966年设立以来，一直是世界计算机科学领域的最高荣誉，相当于计算机科学界的诺贝尔奖。至今，中国人只有姚期智院士获该奖项。

<h4>冯·诺伊曼</h4>

<p>20世纪最重要的数学家之一，在现代计算机、博弈论、核武器和生化武器等诸多领域内有杰出建树的最伟大的科学金才之一，被后人称为“<strong>计算机之父</strong>”和“ <strong>博弈论之父</strong> ”。<br>计算机的基本工作原理是存储程序和程序控制，它是由世界著名的数学家冯·诺依曼提出的。<strong>最简单的来说，冯诺依曼理论的要点是：数学计算机的数制采用二进制；计算机应该按照程序顺序执行。</strong><br>同样有着“计算机之父”称号的冯·诺依曼的助手弗兰克尔在一封信中写到：“……计算机的基本概念属于图灵。按照我的看法，冯·诺依曼的基本作用是使世界认识了由图灵引入的计算机基本概念……”</p>
<h2 id="0-4-操作系统"><a href="#0-4-操作系统" class="headerlink" title="0.4 操作系统"></a>0.4 操作系统</h2><ul>
<li>操作系统(Operating System)是运行在计算机上的最重要的程序，它可以管理和控制计算机的活动。</li>
<li>硬件、操作系统、应用程序和用户之间的关系如下图。</li>
</ul>
<p><img src="../img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%85%B6%E5%AE%83%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E5%BF%B5%E7%9A%84%E5%85%B3%E7%B3%BB.jpg#pic_center" alt="操作系统和其它概念的关系"></p>
<center><b>图0-11 操作系统和其它概念的关系</b></center>

<ul>
<li>操作系统的主要任务：<ul>
<li>控制和监视系统的活动</li>
<li>分配和调配系统资源</li>
<li>调度操作</li>
</ul>
</li>
</ul>
<h2 id="0-5-万维网"><a href="#0-5-万维网" class="headerlink" title="0.5 万维网"></a>0.5 万维网</h2><p><strong>万维网(World Wide Web,www,环球信息网)常简称为Web</strong>，发明者蒂姆·博纳斯·李。分为<strong>Web客户端</strong>和<strong>Web服务器程序</strong>。WWW可以让Web客户端(常用浏览器)访问浏览Web服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局 <strong>“统一资源定位符”(URL)</strong> 标识；有些资源通过<strong>超文本传输协议(Hypertext Transfer Protocol)</strong> 传送给用户，而后者通过点击链接来获得资源。<br>URL例如：www.sina.com</p>
<p><img src="../img/%E4%B8%87%E7%BB%B4%E7%BD%91%E3%80%81%E5%9B%A0%E7%89%B9%E7%BD%91%E5%92%8C%E4%BA%92%E8%81%94%E7%BD%91%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.jpg#pic_center" alt="万维网、因特网、互联网之间的关系"></p>
<center><b>图0-12 万维网、因特网、互联网之间的关系(包含和被包含的关系)</b></center>

<p><strong>万维网是无数个网络站点和网页的集合，它们在一起构成了因特网最主要的部分</strong>(因特网也包括电子邮件、Usenet以及新闻组)。它实际上是多媒体的集合，是由超级链接连接而成的。我们通常通过网络浏览器上网观看的，就是万维网的内容。</p>
<p><img src="../img/%E7%BD%91%E7%BB%9C.jpg#pic_center" alt="万维网"></p>
<center><b>图0-13 万维网</b></center>

<p>软件架构：</p>
<ul>
<li>B/S架构，浏览器/服务器架构，通过浏览器访问服务器。</li>
<li>C/S架构，客户端/服务器架构，通过客户端访问服务器。<br>www或Web使用B/S架构。</li>
</ul>
<h2 id="0-6-职业发展与提升"><a href="#0-6-职业发展与提升" class="headerlink" title="0.6 职业发展与提升"></a>0.6 职业发展与提升</h2><p><img src="../img/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%B7%B3%E6%A7%BD%E5%85%A8%E6%94%BB%E7%95%A5.jpg#pic_center" alt="职业路线"></p>
<center><b>图0-14 IT行业职业路线</b></center>

<p><img src="../img/94e5d7b332f240829fb28a3d24e355c1.png#pic_center" alt="亚信公司职业路径"></p>
<center><b>图0-15 亚信公司提出的职业路径</b></center>

<p><img src="../img/%E4%B8%93%E4%B8%9A%E8%81%8C%E7%BA%A71.jpg#pic_center" alt="专业职级(1/2)"></p>
<center><b>图0-16 专业职级(1/2)</b></center>

<p><img src="../img/%E4%B8%93%E4%B8%9A%E8%81%8C%E7%BA%A72.jpg#pic_center" alt="专业职级(2/2)"></p>
<center><b>图0-17 专业职级(2/2)</b></center>

<p><br/></p>
<p><img src="../img/%E7%AE%A1%E7%90%86%E8%81%8C%E7%BA%A7.jpg#pic_center" alt="管理职级"></p>
<p><center><b>图0-18 管理职级</b></center><br><br/></p>
<p><img src="../img/e681a189b0b146009fb91e874c9022f6.png#pic_center" alt="学习规律"></p>
<p><center><b>图0-19 学习规律</b></center><br><br/></p>
<h2 id="0-7-学习经验探讨"><a href="#0-7-学习经验探讨" class="headerlink" title="0.7 学习经验探讨"></a>0.7 学习经验探讨</h2><ul>
<li>锻炼“双核”处理，边听边思考，边做“笔记”</li>
<li>纸上得来终觉浅，绝知此事要躬行！<ul>
<li>第一层次：看得懂(依赖于视频、书、帖子)</li>
<li>第二层次：练的熟(每天代码必须实现<strong>2-3遍</strong>)</li>
<li>总结：<strong>三分看，七分练</strong></li>
</ul>
</li>
<li>建立行之有效的学习方法<ul>
<li>学习编程的捷径：<strong>敲，狂敲</strong></li>
<li><strong>“模仿”</strong> 好的编码习惯</li>
<li>整理、回顾：<strong>每天花30min整理</strong></li>
</ul>
</li>
<li>一开始需要模仿</li>
<li>知识变为技能，需要长时间的积累</li>
<li>四种心态<ul>
<li>不是“没听懂”，而是“记不住”</li>
<li>要为成功找理由，不为失败找借口</li>
<li>战略上藐视“对手”，战术上重视“对手”</li>
<li>“代码虐我千百遍，我视代码如初恋”</li>
</ul>
</li>
</ul>
<p><strong>注：绝大多数文字来源于尚硅谷；图0-1、0-4、0-5、0-8、0-10、0-11、0-12、0-13自绘，其余图片来源于尚硅谷和网络，仅用于学习。</strong></p>
]]></content>
      <categories>
        <category>计算机基础知识</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>职业规划</tag>
        <tag>尚硅谷java核心基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【晴问算法】入门篇—贪心算法—经典例题和个人题解</title>
    <url>/2023/03/04/%E3%80%90%E6%99%B4%E9%97%AE%E7%AE%97%E6%B3%95%E3%80%91%E5%85%A5%E9%97%A8%E7%AF%87%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E2%80%94%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98%E5%92%8C%E4%B8%AA%E4%BA%BA%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>OJ平台链接</strong>：<a href="https://sunnywhy.com/sfbj/4/4/149">https://sunnywhy.com/sfbj/4/4/149</a></p>
<h2 id="什么是贪心算法？"><a href="#什么是贪心算法？" class="headerlink" title="什么是贪心算法？"></a>什么是贪心算法？</h2><p><strong>定义</strong>：<strong>采用局部最优的策略能得到全局最优的结果。</strong><br>然而，并不是所有问题都适用贪心算法，完全适用贪心算法的问题必须具有<strong>最优子结构</strong>。针对不完全适用的问题，利用贪心算法，往往只能得到较优解，而并非是最优解。<br>通俗地讲，假如贪心算法适用于统一天下的问题，那么，刘皇叔完全不用考虑天下大势，每次只要让当前战役所取得的利益最大，损失最小，他就能统一天下。<br>最优子结构意味着只要局部利益最大化就一定能达到全局利益最大化，追求当前局部利益最大化不会损失往后的局部利益，不存在着为了长远利益，而主动牺牲当前的利益这样的现象，只需考虑眼前的利益最大化就可以了，就一定能够达成全局利益最大化的结果。</p>
<hr/>

<h1 id="1-最优装箱"><a href="#1-最优装箱" class="headerlink" title="1. 最优装箱"></a>1. 最优装箱</h1><p><strong>题目描述</strong><br>有$n$个箱子需要装上一艘轮船，已知第$i$个箱子的重量为$w_i$，轮船的载重为$W$。问在不超过轮船载重的前提下，最多能把多少个箱子装上轮船。</p>
<p><strong>输入描述</strong><br>第一行两个正整数$n$、$W$（$1{\le}n{\le}10^5$、$1{\le}W{\le}10^7$），分别表示箱子个数和轮船载重。</p>
<p>第二行$n$个正整数$w_i$（$1{\le}w_i{\le}10^7$），表示$n$个箱子的重量。</p>
<p><strong>输出描述</strong><br>输出两个整数，分别表示能装上轮船的箱子个数和总重量，用空格隔开。</p>
<p><strong>样例1</strong><br><strong>输入</strong><br>5 11<br>7 2 9 1 11<br><strong>输出</strong><br>3 10<br><strong>解释</strong><br>能将重量分别为7、2、1的箱子装上轮船（此时箱子个数最多），总重量为10。</p>
<h2 id="下面是对这道题的解答："><a href="#下面是对这道题的解答：" class="headerlink" title="下面是对这道题的解答："></a>下面是对这道题的解答：</h2><p><strong>贪心策略：</strong> 对箱子按照重量从小到大排序，每次拿箱子都拿重量最小的那个箱子，直到不能拿为止（不允许总重量超过轮船载重）。</p>
<p><strong>代码：</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">100005</span>]; <span class="comment">//表示每个箱子的重量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,n,W;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//sum表示当前已拿箱子的总重量</span></span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">//cnt表示当前已拿箱子的数量</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;W); <span class="comment">//n表示箱子个数，W表示轮船最大载重</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]); <span class="comment">//读入每个箱子的重量</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(a,a+n); <span class="comment">//按箱子的重量从小到大排序，贪心策略是优先选择重量小的箱子</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(sum+a[i]&gt;W) <span class="keyword">break</span>; <span class="comment">//如果拿了当前的箱子会导致超重的话，就不再继续拿箱子</span></span><br><span class="line">		<span class="keyword">else</span>&#123;<span class="comment">//如果不会超重，那么拿当前的箱子</span></span><br><span class="line">			cnt++; <span class="comment">//已拿箱子个数加1</span></span><br><span class="line">			sum+=a[i];<span class="comment">//已拿箱子的总重量加上新拿箱子的重量</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,cnt,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr/>


<h1 id="2-整数配对"><a href="#2-整数配对" class="headerlink" title="2. 整数配对"></a>2. 整数配对</h1><p><strong>题目描述</strong><br>有两个正整数集合$S$、$T$，其中$S$中有$n$个正整数，$T$中有$m$个正整数。定义一次配对操作为：从两个集合中各取出一个数$a$和$b$，满足$a \in S$、$b \in T$、$a \le b$，配对的数不能再放回集合。问最多可以进行多少次这样的配对操作。</p>
<p><strong>输入描述</strong><br>第一行两个正整数$n$、$m$（$1{\le}n{\le}10^4$、$1{\le}m{\le}10^4$），分别表示$S$和$T$中正整数的个数。</p>
<p>第二行$n$个正整数（$1{\le}a_i{\le}10^5$），表示$S$中的$n$个正整数。</p>
<p>第三行$m$个正整数（$1{\le}b_i{\le}10^5$），表示$T$中的$m$个正整数。</p>
<p><strong>输出描述</strong><br>输出一个整数，表示最多的配对操作次数。</p>
<p><strong>样例1</strong><br><strong>输入</strong><br>3 3<br>2 5 3<br>3 3 4<br><strong>输出</strong><br>2<br><strong>解释</strong><br>2与其中一个3配对，3与另一个3配对，5无法和4配对。因此最多配对两次。</p>
<h2 id="下面是对这道题的解答：-1"><a href="#下面是对这道题的解答：-1" class="headerlink" title="下面是对这道题的解答："></a>下面是对这道题的解答：</h2><p><strong>贪心策略：</strong> 对集合S和集合T均从小到大排序，针对集合S中的每一个元素，选择集合T中尽可能小的但是又比集合S中的当前元素大的元素，保证配对总数最大，避免非常小的元素配对非常大的元素，导致其它元素配不到对。</p>
<p><strong>代码：</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m,tp,i,j;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//表示当前已配对数</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1,v2; <span class="comment">//向量v1存储集合S的元素，向量v2存储集合T的元素</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tp); <span class="comment">//读入集合S的元素，允许重复</span></span><br><span class="line">		v1.<span class="built_in">push_back</span>(tp); <span class="comment">//将元素放入集合S</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>()); <span class="comment">//对集合S的元素从小到大排序</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tp); <span class="comment">//读入集合T的元素，允许重复</span></span><br><span class="line">		v2.<span class="built_in">push_back</span>(tp); <span class="comment">//将元素放入集合T</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(v2.<span class="built_in">begin</span>(),v2.<span class="built_in">end</span>()); <span class="comment">//对集合T的元素从小到大排序</span></span><br><span class="line">	j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;)&#123;</span><br><span class="line">		<span class="keyword">if</span>(v1[i]&lt;=v2[j])&#123; <span class="comment">//如果集合S当前元素小于等于集合T当前元素，可以配对</span></span><br><span class="line">			sum++; <span class="comment">//配对数加1</span></span><br><span class="line">			i++; <span class="comment">//配对成功，开始对集合S的下一个元素寻找配对元素</span></span><br><span class="line">		&#125;</span><br><span class="line">		j++; <span class="comment">//考虑集合T的下一个元素</span></span><br><span class="line">		<span class="keyword">if</span>(j==m) <span class="keyword">break</span>; <span class="comment">//如果已经到达集合T的最后一个元素，意味着集合T不再有可以配对的元素</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr/>

<h1 id="3-最大组合整数"><a href="#3-最大组合整数" class="headerlink" title="3. 最大组合整数"></a>3. 最大组合整数</h1><p><strong>题目描述</strong><br>现有0~9中各个数的个数，将它们组合成一个整数，求能组合出的最大整数。</p>
<p><strong>输入描述</strong><br>在一行中依次给出0-9中各个数的个数（所有个数均在0-100之间）。数据保证至少有一个数的个数大于0。</p>
<p><strong>输出描述</strong><br>输出一个整数，表示能组合出的最大整数。</p>
<p><strong>样例1</strong><br><strong>输入</strong><br>1 0 2 0 0 0 0 0 0 1<br><strong>输出</strong><br>9220<br><strong>解释</strong><br>存在1个0、2个2、1个9，因此能组合出的最大整数是9220</p>
<h2 id="下面是对这道题的解答：-2"><a href="#下面是对这道题的解答：-2" class="headerlink" title="下面是对这道题的解答："></a>下面是对这道题的解答：</h2><p><strong>贪心策略：</strong> 要想使得输出整数最大，只要让每次输出的数都是当前可用的最大数，例如，先输出9，再输出8，再7，以此类推，最后输出0，始终让当前可用的最大的数字位于整数的高位，这能保证整数最大。如果某个数字有多个可用，那就输出多个，如果某个数字只有0个可用，那就不用，将其跳过。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">10</span>]; <span class="comment">//存储0-9当中每个数的出现次数</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> flag = <span class="literal">false</span>; <span class="comment">//是否是第一个输出的数字</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">9</span>;i&gt;=<span class="number">0</span>;i--)&#123;  <span class="comment">//从大到小输出数字，最先输出9，最后输出0，这能保证组合而成的整数最大</span></span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!flag&amp;&amp;i==<span class="number">0</span>)&#123; <span class="comment">//如果第一个输出的数字是0，意味着只有0可以用</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>); <span class="comment">//只输出一个0</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(a[i]!=<span class="number">0</span>)&#123; <span class="comment">//将当前数字的次数全部用完</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i); <span class="comment">//输出当前数字</span></span><br><span class="line">				a[i]--; <span class="comment">//可用个数减一</span></span><br><span class="line">			&#125;</span><br><span class="line">			flag = <span class="literal">true</span>; <span class="comment">//表示已经输出了第一个数字</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr/>

<h1 id="4-区间不相交问题"><a href="#4-区间不相交问题" class="headerlink" title="4. 区间不相交问题"></a>4. 区间不相交问题</h1><p><strong>题目描述</strong><br>给定个开区间，从中选择尽可能多的开区间，使得这些开区间两两没有交集。</p>
<p><strong>输入描述</strong><br>第一行为一个正整数$n$（$1{\le}n{\le}10^4$），表示开区间的个数。</p>
<p>接下来$n$行，每行两个正整数$x_i$、$y_i$（$0{\le}x_i{\le}10^5$、$0{\le}y_i{\le}10^5$），分别表示第$i$个开区间的左端点和右端点。</p>
<p><strong>输出描述</strong><br>输出一个整数，表示最多选择的开区间个数。</p>
<p><strong>样例1</strong><br><strong>输入</strong><br>4<br>1 3<br>2 4<br>3 5<br>6 7<br><strong>输出</strong><br>3<br><strong>解释</strong><br>最多选择(1,3)、(3,5)、(6,7)三个区间，它们互相没有交集。</p>
<h2 id="下面是对这道题的解答：-3"><a href="#下面是对这道题的解答：-3" class="headerlink" title="下面是对这道题的解答："></a>下面是对这道题的解答：</h2><p><strong>贪心策略：</strong> 如果要使选取的区间没有交集，必须保证一个区间的左端点比另一个区间的右端点大，而且两两之间如此。所以，优先选取右端点小的而且左端点比上一个选取的区间的右端点大的那个区间，既保证没有交集，又保证右端点较小，为选取更多区间提供了机会。<br>实际上，在不交叉的前提下，优先选取的是区间长度短并且最靠左的区间，不容易挤占其它区间的空间，如此可选的区间会最多。<br><img src="../img/1f1c89f64d214909a58d0c3e0f8afb09.png" alt="例图"><br>如上图所示，红色为选取的区间，蓝色为不选的区间。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qujian</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y; <span class="comment">//x为区间左端点，y为区间右端点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(qujian a,qujian b)</span></span>&#123; <span class="comment">//比较函数，y值小的排在y值大的前面</span></span><br><span class="line">	<span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line">qujian q[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,n;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">1</span>; <span class="comment">//当前已选择的开区间个数</span></span><br><span class="line">	<span class="type">int</span> last; <span class="comment">//上一个选取的区间的右端点值</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="comment">//n表示区间个数</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q[i].x,&amp;q[i].y); <span class="comment">//读入每个区间的区间左端点和区间右端点</span></span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">sort</span>(q,q+n,cmp); <span class="comment">//对每个区间按照区间右端点从小到大排序，优先选右端点小的区间</span></span><br><span class="line">	last = q[<span class="number">0</span>].y; <span class="comment">//区间右端点最小的区间一定可以选取</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(q[i].x&gt;=last)&#123; <span class="comment">//如果当前区间的左端点比上一个选取的右端点还要大，则可以选取，一定没有交集</span></span><br><span class="line">			sum++;<span class="comment">//选取开区间数加1</span></span><br><span class="line">			last = q[i].y; <span class="comment">//存储该区间的右端点，以供下一个选取的区间的左端点和其比较</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr/>

<h1 id="5-区间选点问题"><a href="#5-区间选点问题" class="headerlink" title="5. 区间选点问题"></a>5. 区间选点问题</h1><p><strong>题目描述</strong><br>给定$n$个闭区间，问最少需要确定多少个点，才能使每个闭区间中都至少存在一个点。</p>
<p><strong>输入描述</strong><br>第一行为一个正整数$n$（$1{\le}n{\le}10^4$），表示闭区间的个数。</p>
<p>接下来$n$行，每行两个正整数$x_i$、$y_i$（$0{\le}x_i{\le}10^5$、$0{\le}y_i{\le}10^5$），分别表示第$i$个闭区间的左端点和右端点。</p>
<p><strong>输出描述</strong><br>输出一个整数，表示最少需要确定的点的个数。</p>
<p><strong>样例1</strong><br><strong>输入</strong><br>3<br>1 4<br>2 6<br>5 7<br><strong>输出</strong><br>2<br>解释<br>至少需要两个点（例如3和5）才能保证每个闭区间内都有至少一个点。</p>
<h2 id="下面是对这道题的解答：-4"><a href="#下面是对这道题的解答：-4" class="headerlink" title="下面是对这道题的解答："></a>下面是对这道题的解答：</h2><p><strong>贪心策略：</strong> 对每个区间按照右端点从小到大排序，尽量选取区间的右端点作为确定点，该点能和最多的区间重合。<br><img src="../img/60b90e394e5e4c1cb4f17d2301495d87.png" alt="例图"><br>如上图所示，圆圈指的是确定点。<br><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qujian</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(qujian a,qujian b)</span></span>&#123; <span class="comment">//比较函数</span></span><br><span class="line">	<span class="keyword">if</span>(a.y!=b.y) <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line">qujian q[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,i;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">1</span>; <span class="comment">//sum表示确定的点数</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q[i].x,&amp;q[i].y);<span class="comment">//读入每个区间的左端点和右端点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(q,q+n,cmp); <span class="comment">//对区间按照右端点从小到大排序</span></span><br><span class="line">	<span class="type">int</span> last = q[<span class="number">0</span>].y; <span class="comment">//将第一个区间的右端点作为确定点</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(q[i].x&gt;last)&#123; <span class="comment">//如果当前区间的左端点比上一个区间的右端点要大，确定一个新的点，该点为当前区间的右端点</span></span><br><span class="line">			sum++; <span class="comment">//确定点数加1</span></span><br><span class="line">			last = q[i].y; <span class="comment">//修改last为新确定点的值，用于同下一个区间不叫</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr/>

<h1 id="6-拼接最小数"><a href="#6-拼接最小数" class="headerlink" title="6. 拼接最小数"></a>6. 拼接最小数</h1><p><strong>题目描述</strong><br>给定个可能含有前导0的数字串，将它们按任意顺序拼接，使生成的整数最小。</p>
<p><strong>输入描述</strong><br>第一行为一个正整数$n$（$1{\le}n{\le}10^4$），表示数字串的个数。</p>
<p>第二行给出$n$个数字串（$1{\le}$每个串的长度${\le}9$），用空格隔开。</p>
<p><strong>输出描述</strong><br>输出一个整数，表示能生成的最小整数（需要去掉前导0）。</p>
<p>样例1<br><strong>输入</strong><br>3<br>53 01 2<br><strong>输出</strong><br>1253<br><strong>解释</strong><br>按01、2、53的顺序拼接，能得到最小整数1253。</p>
<h2 id="下面是对这道题的解答：-5"><a href="#下面是对这道题的解答：-5" class="headerlink" title="下面是对这道题的解答："></a>下面是对这道题的解答：</h2><p><strong>贪心策略：</strong> 要使整数最小，只需优先选取字典序较小的字符数串作为整数的高位，字典序较大的字符数串放在低位。<br><strong>注意，排序函数cmp要写成 return a + b &lt; b + a</strong>，若如此写，假设a=120，b=12；a+b=12012，b+a=12120，那么，120会排在12的前面；如果写成return a&lt;b，这会使得120排在12的后面，为了使得形成的整数串最小，120必须作为高位，12作为低位，因为12012&lt;12120。<br><strong>注</strong>：对于cmp函数，当return true时，string a排在string b的前面；当return false时，string a排在string b后面。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(string a, string b)</span> </span>&#123; <span class="comment">//比较函数，字符串按字典序从小到大排序</span></span><br><span class="line">    <span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n, i, j;</span><br><span class="line">	string s[<span class="number">10005</span>];</span><br><span class="line">	string str;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(s, s + n,cmp); <span class="comment">//对数字串按字典序从小到大排序</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		str.<span class="built_in">append</span>(s[i]); <span class="comment">//将排序后的数字串按序写入，形成整数串</span></span><br><span class="line">	&#125;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (str[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp;  i&lt;str.<span class="built_in">length</span>()) i++; <span class="comment">//去除前导0</span></span><br><span class="line">	<span class="keyword">if</span> (i==str.<span class="built_in">length</span>()) &#123;<span class="comment">//如果整数串全是0，现在已经成空串了</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;0&quot;</span>; <span class="comment">//整数为0</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = i; j &lt; str.<span class="built_in">length</span>(); j++) &#123; <span class="comment">//输出去除前导0的整数</span></span><br><span class="line">			cout &lt;&lt; str[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心算法</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
